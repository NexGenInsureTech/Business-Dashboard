
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Intermediary PDF Builder (HTML+CSS+JS)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>

<!-- Local Bulma CSS -->
  <link rel="stylesheet" href="assets/css/app.css">
  <link rel="stylesheet" href="assets/css/bulma.min.css">

  
</head>

<body>
<header>
  <h1><strong>Intermediary PDF Builder</strong></h1>
  <p class="muted">Upload monthly summary + master register → edit Letter → generate PDFs per Intermediary.</p>
</header>

<section class="card">
  <h2>1) Upload Excel files</h2>
  <label>Monthly Summary (columns: INTERMEDIARY, Apr-25 … Dec-25, Grand Total)
    <input id="monthlyFile" type="file" accept=".xlsx,.xls,.csv" required>
  </label>
  <label>Master Register (SME_PR_MASTER_FY25-26.xlsx)
    <input id="masterFile" type="file" accept=".xlsx,.xls" required>
  </label>

  <div class="grid">
    <label>Monthly sheet name/index (optional)
      <input id="monthlySheet" type="text" placeholder="e.g., Monthly or 0">
    </label>
    <label>Period Label (shown on PDFs)
      <input id="periodLabel" type="text" placeholder="FY25–26 through Dec 2025">
    </label>
  </div>

  <button id="btnParse">Validate & Parse</button>
  <div id="parseResult" class="muted"></div>
</section>

<section class="card">
  <h2>2) Letter page (fully editable)</h2>
  <p class="muted">
    Supported placeholders:
    <code>{{PartnerName}}</code>, <code>{{Category}}</code>,
    <code>{{PeriodLabel}}</code>, <code>{{TotalGross}}</code>
  </p>
  <textarea id="letterText" rows="10"><b>Dear {{PartnerName}},</b><br/><br/>
Thank you for being a Smartian and helping us build a sustainable, customer‑centric business with USGI.
Your commitment to quality and responsible growth inspires our teams every day.<br/><br/>
Below is your performance summary for <b>{{PeriodLabel}}</b>.<br/><br/>
Warm regards,<br/>
SME & Insurance Inclusion — USGI</textarea>

  <div class="grid">
    <label>Select a partner to preview
      <select id="partnerSelect"></select>
    </label>
    <button id="btnPreview">Preview PDF (single partner)</button>
  </div>

  <div id="previewLink" class="muted"></div>

  <!-- Hidden letter render container -->
  <div id="letterPreview" style="position:absolute; left:-9999px; top:-9999px; width:550px;"></div>
</section>

<section class="card">
  <h2>3) Generate PDFs</h2>
  <div class="options grid">
    <label><input id="includeLOB" type="checkbox" checked> Include LOB split</label>
    <label><input id="includeProducts" type="checkbox" checked> Include Product mix (Intermediary & Channel)</label>
    <label><input id="includeGeo" type="checkbox" checked> Include Geography (States & Branches)</label>
  </div>
  <button id="btnGenerate">Generate All PDFs (ZIP)</button>
  <div id="generateStatus" class="muted"></div>
</section>

<footer class="muted">
  <small>© USGI — SME & Insurance Inclusion</small>
</footer>

<!-- Local JS libraries -->
  <script src="assets/js/xlsx.full.min.js"></script>

  <!-- jsPDF must come BEFORE the AutoTable plugin -->
  <script src="assets/js/jspdf.umd.min.js"></script>
  <script src="assets/js/jspdf.plugin.autotable.min.js"></script>

  <script src="assets/js/chart.umd.min.js"></script>
  <script src="assets/js/jszip.min.js"></script>
  <script src="assets/js/html2canvas.min.js"></script>


<!-- App Code (after libraries) -->
<script>
(function(){
  // Bind UMD globals safely
  const XLSXLoaded = !!window.XLSX;
  const jsPDFLoaded = !!(window.jspdf && window.jspdf.jsPDF);
  const autoTableFunc = (window.jspdf && window.jspdf.autoTable) || null;

  if (!XLSXLoaded || !jsPDFLoaded){
    alert('Error: Required libraries did not load. Check asset paths and script order.');
    console.error('XLSX:', XLSXLoaded, 'jsPDF:', jsPDFLoaded, 'autoTable:', !!autoTableFunc);
    return;
  }

  // Shim: support both autotable styles (doc.autoTable and autoTable(doc, opts))
  const { jsPDF } = window.jspdf;
  const autop = autoTableFunc;
  const autoTableShim = (doc, opts) => {
    if (typeof doc.autoTable === 'function') return doc.autoTable(opts);
    if (typeof autop === 'function') return autop(doc, opts);
    throw new Error('AutoTable plugin not available');
  };

  const MONTH_REGEX = /^[A-Za-z]{3}-\d{2}$/;
  const monMap = {Jan:1,Feb:2,Mar:3,Apr:4,May:5,Jun:6,Jul:7,Aug:8,Sep:9,Oct:10,Nov:11,Dec:12};
  const monNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

  let monthlyRows = [];    // normalized rows from monthly sheet
  let masterRows  = [];    // rows from master register
  let monthCols   = [];    // normalized ["Jan-25","Feb-25",...]
  let partners    = [];    // unique partner names
  let catMap      = {};    // partner -> category
  let periodLabel = "";    // display label for PDFs

  const parseResultEl = document.getElementById('parseResult');
  const partnerSelect = document.getElementById('partnerSelect');

  // ---------- Helpers ----------
  const rupee = (x) => {
    const v = Number(x || 0), ax = Math.abs(v);
    if (ax >= 1e7)  return `₹${(v/1e7).toFixed(1)} Cr`;
    if (ax >= 1e5)  return `₹${(v/1e5).toFixed(1)} L`;
    return `₹${Math.round(v).toLocaleString()}`;
  };
  const isMonthCol = (c) => MONTH_REGEX.test(String(c).trim());
  const tsOfMonth = (m) => {
    const [abbr, yy] = m.split('-');
    const y = Number('20'+yy);
    const mon = monMap[abbr];
    return new Date(y, mon-1, 1);
  };
  const numberize = (val) => {
    if (val===null || val===undefined || val==='') return 0;
    const n = Number(String(val).replace(/,/g,''));
    return isFinite(n) ? n : 0;
  };
  const normalizeCols = (row) => {
    const out = {};
    for (const k of Object.keys(row)) out[String(k).trim()] = row[k];
    return out;
  };
  const replacePlaceholders = (txt, ctx) => (
    txt.replaceAll('{{PartnerName}}', ctx.partner)
       .replaceAll('{{Category}}', ctx.category)
       .replaceAll('{{PeriodLabel}}', ctx.period)
       .replaceAll('{{TotalGross}}', rupee(ctx.totalGross))
  );

  // Accept dd/mm/yyyy or yyyy-mm-dd headers and convert to "MMM-YY"
  const looksLikeDateHeader = (h) => {
    const s = String(h).trim();
    return /^\d{1,2}[\/-]\d{1,2}[\/-]\d{4}$/.test(s) || /^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(s);
  };
  const normalizeMonthHeader = (h) => {
    const s = String(h).trim();
    let y, m;
    if (/^\d{1,2}[\/-]\d{1,2}[\/-]\d{4}$/.test(s)){
      const [a,b,c] = s.split(/[\/-]/).map(Number);
      m = (a>12 ? b : a); y = c;
    } else if (/^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(s)){
      const [c,a,b] = s.split(/[\/-]/).map(Number);
      y = c; m = a;
    } else {
      if (MONTH_REGEX.test(s)) return s;
      return s;
    }
    const mon = monNames[Math.max(1,Math.min(12,m)) - 1];
    return `${mon}-${String(y).slice(-2)}`;
  };

  // CSV + XLSX support
  const readWorkbook = async (file, sheetArg) => {
    const ext = (file.name||'').split('.').pop().toLowerCase();
    let wb;
    if (ext === 'csv'){
      const text = await file.text();
      wb = XLSX.read(text, {type:'string'});
    } else {
      const buf = await file.arrayBuffer();
      wb = XLSX.read(buf, {type:'array'});
    }
    const sheetName = (typeof sheetArg === 'string' && sheetArg !== '')
      ? (isFinite(sheetArg) ? wb.SheetNames[Number(sheetArg)] : sheetArg)
      : wb.SheetNames[0];
    const ws = wb.Sheets[sheetName];
    if (!ws) throw new Error(`Sheet "${sheetName}" not found. Available: ${wb.SheetNames.join(', ')}`);
    return XLSX.utils.sheet_to_json(ws, {defval:null});
  };

  // Fallback for INTERMEDIARY column name
  const findIntermediaryColumn = (rows) => {
    if (!rows.length) return null;
    const headers = Object.keys(rows[0]);
    const candidates = ['INTERMEDIARY','Intermediary','Intermediary Name','Partner','Agent','Broker'];
    for (const c of candidates){
      const h = headers.find(h => h.trim().toLowerCase() === c.trim().toLowerCase());
      if (h) return h;
    }
    return null;
  };

  // ---------- Validate & Parse ----------
  document.getElementById('btnParse').addEventListener('click', async () => {
    try {
      parseResultEl.textContent = 'Parsing…';
      const monthlyFile = document.getElementById('monthlyFile').files[0];
      const masterFile  = document.getElementById('masterFile').files[0];
      const monthlySheet= document.getElementById('monthlySheet').value.trim();
      periodLabel = document.getElementById('periodLabel').value.trim();

      if (!monthlyFile || !masterFile) {
        parseResultEl.textContent = 'Please upload both files.';
        return;
      }

      // Read once (no duplicate reads)
      let mRaw, masterRaw;
      try {
        mRaw = (await readWorkbook(monthlyFile, monthlySheet)).map(normalizeCols);
      } catch (err) {
        parseResultEl.textContent = `Monthly file error: ${err.message}`;
        return;
      }
      try {
        masterRaw = (await readWorkbook(masterFile, 0)).map(normalizeCols);
      } catch (err) {
        parseResultEl.textContent = `Master file error: ${err.message}`;
        return;
      }

      if (!mRaw.length){
        parseResultEl.textContent = 'Monthly sheet returned 0 rows. Check the sheet name/index.';
        return;
      }

      // Normalize month headers (MMM-YY) and numberize values
      const rawMonthCols = Object.keys(mRaw[0]).filter(h => MONTH_REGEX.test(h) || looksLikeDateHeader(h));
      const headerMap = {};
      rawMonthCols.forEach(h => headerMap[h] = normalizeMonthHeader(h));

      monthlyRows = mRaw.map(row => {
        const out = {};
        for (const k of Object.keys(row)){
          if (MONTH_REGEX.test(k) || looksLikeDateHeader(k)){
            const norm = headerMap[k];
            out[norm] = numberize(row[k]);
          } else {
            out[k] = row[k];
          }
        }
        if ('Grand Total' in out) out['Grand Total'] = numberize(out['Grand Total']);
        return out;
      });

      // Build final monthCols and sort chronologically
      monthCols = Array.from(
        new Set(Object.keys(monthlyRows[0]).filter(isMonthCol))
      ).sort((a,b) => tsOfMonth(a) - tsOfMonth(b));

      // Determine intermediary column and build unique partners
      const intermCol = findIntermediaryColumn(monthlyRows);
      if (!intermCol){
        parseResultEl.textContent = 'Could not locate an Intermediary column (expected: INTERMEDIARY / Intermediary Name / Partner / Agent / Broker).';
        return;
      }
      monthlyRows = monthlyRows.map(r => { r[intermCol] = String(r[intermCol]||'').trim(); return r; });
      partners = Array.from(new Set(monthlyRows.map(r => r[intermCol]).filter(Boolean))); // dedupe
      partnerSelect.dataset.intermCol = intermCol;

      // Master rows and category map
      masterRows = masterRaw;
      catMap = {};
      masterRows.forEach(r => {
        const name = String(r['INTERMEDIARY']||'').trim();
        const cat  = String(r['INTERMEDIARY CATEGORY']||'').trim() || 'Others';
        if (name) catMap[name] = cat;
      });

      // Default period label if blank
      if (!periodLabel && monthCols.length) {
        const last = monthCols.map(tsOfMonth).sort((a,b)=>a-b).pop();
        periodLabel = last ? last.toLocaleString('en-GB', {month:'short', year:'numeric'}) : 'FY25–26';
        document.getElementById('periodLabel').value = periodLabel;
      }

      // Populate partner dropdown
      partnerSelect.innerHTML = '';
      partners.slice(0, 2000).forEach(p => {
        const opt = document.createElement('option');
        opt.value = p; opt.textContent = p;
        partnerSelect.appendChild(opt);
      });

      parseResultEl.textContent =
        `Parsed ${partners.length} intermediaries. Months: ${monthCols.length ? monthCols.join(', ') : '(none found)'}`;
    } catch (e) {
      console.error(e);
      parseResultEl.textContent = 'Error: ' + e.message;
    }
  });

  // ---------- Master data helpers ----------
  function masterSlice(partner){
    return masterRows.filter(r => String(r['INTERMEDIARY']||'').trim()===partner);
  }
  function sumCol(colName, partner){
    return masterSlice(partner).reduce((s,r)=> s + numberize(r[colName]), 0);
  }
  function sumInsured(partner){
    const rows = masterSlice(partner);
    const hasUSGI = rows.some(r => r['USGI SUM INSURED']!=null);
    const key = hasUSGI ? 'USGI SUM INSURED' : 'TOTAL SUM INSURED';
    return rows.reduce((s,r)=> s + numberize(r[key]), 0);
  }
  function uniquePolicies(partner){
    const rows = masterSlice(partner);
    const nums = new Set();
    rows.forEach(r => {
      const a = r['POLICY NO'], b = r['POLICY NO CHAR'];
      if (a) nums.add(String(a));
      if (b) nums.add(String(b));
    });
    return nums.size;
  }
  function groupSum(field, valueCol, partner){
    const rows = masterSlice(partner);
    const m = new Map();
    rows.forEach(r => {
      const k = String(r[field]||'').trim() || '—';
      m.set(k, (m.get(k)||0) + numberize(r[valueCol]));
    });
    return m;
  }
  function groupSumCategory(field, valueCol, category){
    const rows = masterRows.filter(r => String(r['INTERMEDIARY CATEGORY']||'').trim()===category);
    const m = new Map();
    rows.forEach(r => {
      const k = String(r[field]||'').trim() || '—';
      m.set(k, (m.get(k)||0) + numberize(r[valueCol]));
    });
    return m;
  }
  function topSeries(map, topN){
    const arr = Array.from(map.entries()).sort((a,b)=>b[1]-a[1]).slice(0, topN);
    return arr.length ? arr.map(([k,v])=>[k, rupee(v)]) : [['No Data','—']];
  }
  function sumBusinessType(keyword, partner){
    return masterSlice(partner)
      .filter(r => String(r['Business Type Fresh Renewal'] ?? r['Business Type'] ?? '')
        .toLowerCase().includes(keyword.toLowerCase()))
      .reduce((s,r)=> s + numberize(r['GROSS PREMIUM']), 0);
  }
  function sumEndorsement(partner){
    return masterSlice(partner)
      .filter(r => String(r['Business Type Fresh Renewal'] ?? r['Business Type'] ?? '')
        .toLowerCase().includes('endorsement'))
      .reduce((s,r)=> s + numberize(r['GROSS PREMIUM']), 0);
  }

  // ---------- PDF builder ----------
  async function buildPdfForPartner(partner, cfg){
    console.log('[Preview] Build start', { partner });
    const doc = new jsPDF({unit:'pt', format:'a4'});
    const margin = 32;

    // Resolve monthly row & category
    const intermCol = partnerSelect.dataset.intermCol || 'INTERMEDIARY';
    const mRow = monthlyRows.find(r => r[intermCol]===partner) || {};
    const category = catMap[partner] || 'Others';
    console.log('[Preview] mRow found?', !!mRow, 'category:', category);

    // Compute totals
    let totalGross = 0;
    if('Grand Total' in mRow) totalGross = numberize(mRow['Grand Total']);
    else if (monthCols.length) totalGross = monthCols.reduce((s,m)=> s + numberize(mRow[m]), 0);
    console.log('[Preview] totalGross', totalGross);

    // ---- Page 1: Letter (rendered via html2canvas) ----
    try {
      const letter = replacePlaceholders(cfg.letterHTML, {
        partner, category, period:periodLabel, totalGross
      });
      const container = document.getElementById('letterPreview');
      container.innerHTML = letter;
      const canvas = await html2canvas(container, {scale:2});
      const imgData = canvas.toDataURL('image/png');
      const pageW = doc.internal.pageSize.getWidth();
      const imgW = pageW - margin*2;
      const imgH = imgW * (canvas.height/canvas.width);
      doc.addImage(imgData, 'PNG', margin, margin, imgW, imgH);
      doc.addPage();
      console.log('[Preview] Letter rendered');
    } catch (err) {
      console.error('[Preview] Letter render failed:', err);
      doc.setFontSize(14);
      doc.text(`Dear ${partner},`, margin, margin+20);
      doc.text(`Total Gross: ${rupee(totalGross)}`, margin, margin+40);
      doc.addPage();
    }

    // ---- Page 2: KPIs + MoM + Mix ----
    try {
      const kpis = [
        ['Gross Premium (sum)', rupee(totalGross)],
        ['Net Premium', rupee(sumCol('NET PREMIUM', partner))],
        ['Policies (unique)', String(uniquePolicies(partner))],
        ['GST Collected', rupee(sumCol('Total Gst', partner))],
        ['Commission Amount', rupee(sumCol('COMMISSION AMOUNT', partner))],
        ['Sum Insured', rupee(sumInsured(partner))]
      ];
      doc.setFontSize(16);
      doc.text(`Performance Summary — ${partner} (${category})`, margin, margin+18);
      doc.setFontSize(11);
      doc.text(`Period: ${periodLabel || ''}`, margin, margin+34);

      autoTableShim(doc, {
        head:[['Metric','Value']],
        body:kpis,
        startY: margin+48,
        theme:'grid',
        styles:{fontSize:9},
        headStyles:{fillColor:[232,240,254]},
        columnStyles:{0:{cellWidth:240},1:{cellWidth:240}}
      });
      console.log('[Preview] KPI table done, finalY:', doc.lastAutoTable?.finalY);
    } catch (err) {
      console.error('[Preview] KPI AutoTable failed:', err);
    }

    let cursorY = doc.lastAutoTable?.finalY ? (doc.lastAutoTable.finalY + 10) : (margin + 200);

    // Month-on-Month chart from monthly columns (skip if none)
    if (monthCols.length){
      const labels = monthCols.slice();
      const data = monthCols.map(m => numberize(mRow[m]));
      const chartCanvas = document.createElement('canvas');
      chartCanvas.width = 680; chartCanvas.height = 300;
      document.body.appendChild(chartCanvas);
      const chart = new Chart(chartCanvas.getContext('2d'), {
        type:'bar',
        data:{labels, datasets:[{label:'Gross Premium', data, backgroundColor:'#2f5597'}]},
        options:{responsive:false, scales:{y:{ticks:{callback:(v)=>rupee(v)}}}}
      });
      await new Promise(r => setTimeout(r, 200));
      const chartImg = chartCanvas.toDataURL('image/png');
      chart.destroy();    
      document.body.removeChild(chartCanvas);
      const pageW2 = doc.internal.pageSize.getWidth();
      doc.addImage(chartImg, 'PNG', margin, cursorY, pageW2 - margin*2, 160);
      cursorY += 170;
    } else {
      doc.setFontSize(11);
      doc.text('No month-wise data found in Monthly Summary (chart skipped).', margin, cursorY);
      cursorY += 20;
    }

    // Product & LOB mixes
    if (cfg.includeProducts){
      doc.setFontSize(12);
      doc.text('Product Mix — Intermediary', margin, cursorY);
      autoTableShim(doc, {
        head:[['Product','Gross Premium']],
        body: topSeries(groupSum('PRODUCT NAME','GROSS PREMIUM', partner), 8),
        startY: cursorY+6, theme:'grid', styles:{fontSize:9},
        columnStyles:{0:{cellWidth:280},1:{cellWidth:200}}
      });
      cursorY = doc.lastAutoTable.finalY + 10;

      doc.text(`Product Mix — Channel (${category})`, margin, cursorY);
      autoTableShim(doc, {
        head:[['Product','Gross Premium']],
        body: topSeries(groupSumCategory('PRODUCT NAME','GROSS PREMIUM', category), 8),
        startY: cursorY+6, theme:'grid', styles:{fontSize:9},
        columnStyles:{0:{cellWidth:280},1:{cellWidth:200}}
      });
      cursorY = doc.lastAutoTable.finalY + 10;
    }

    if (cfg.includeLOB){
      doc.text('Line of Business Split — Intermediary', margin, cursorY);
      autoTableShim(doc, {
        head:[['LOB','Gross Premium']],
        body: topSeries(groupSum('LINE OF BUSINESS','GROSS PREMIUM', partner), 6),
        startY: cursorY+6, theme:'grid', styles:{fontSize:9},
        columnStyles:{0:{cellWidth:280},1:{cellWidth:200}}
      });
      cursorY = doc.lastAutoTable.finalY + 10;
    }

    const btNew = sumBusinessType('New', partner);
    const btRen = sumBusinessType('Renewal', partner);
    const btEnd = sumEndorsement(partner);
    doc.setFontSize(11);
    doc.text(`Business Type — New: ${rupee(btNew)} | Renewal: ${rupee(btRen)} | Endorsements: ${rupee(btEnd)}`, margin, cursorY);

    // ---- Page 3: Geography ----
    if (cfg.includeGeo){
      doc.addPage();
      doc.setFontSize(16);
      doc.text(`Geography — ${partner}`, margin, margin+18);

      doc.setFontSize(12);
      doc.text('Top States', margin, margin+38);
      autoTableShim(doc, {
        head:[['State','Gross Premium']],
        body: topSeries(groupSum('STATE','GROSS PREMIUM', partner), 10),
        startY: margin+44, theme:'grid', styles:{fontSize:9},
        columnStyles:{0:{cellWidth:280},1:{cellWidth:200}}
      });

      let y2 = doc.lastAutoTable.finalY + 10;
      doc.text('Top Branches', margin, y2);
      autoTableShim(doc, {
        head:[['Branch','Gross Premium']],
        body: topSeries(groupSum('BRANCH NAME','GROSS PREMIUM', partner), 10),
        startY: y2+6, theme:'grid', styles:{fontSize:9},
        columnStyles:{0:{cellWidth:280},1:{cellWidth:200}}
      });
    }

    return doc.output('blob');
  }

  // ---------- Preview & Generate ----------
  document.getElementById('btnPreview').addEventListener('click', async () => {
    console.log('[Preview] Clicked. Partner:', partnerSelect.value);
    try {
      const partner = partnerSelect.value;
      if (!partner){ alert('Select a partner'); return; }
      const cfg = {
        letterHTML: document.getElementById('letterText').value,
        includeLOB: document.getElementById('includeLOB').checked,
        includeProducts: document.getElementById('includeProducts').checked,
        includeGeo: document.getElementById('includeGeo').checked
      };
      const blob = await buildPdfForPartner(partner, cfg);
      const url = URL.createObjectURL(blob);
      document.getElementById('previewLink').innerHTML = 	
       `Preview: ${url}Open PDF</a>`;
    } catch (e) {
      console.error(e);
      document.getElementById('previewLink').textContent = 'Error: '+e.message;
    }
  });

  document.getElementById('btnGenerate').addEventListener('click', async () => {
    try {
      const statusEl = document.getElementById('generateStatus');
      statusEl.textContent = 'Generating PDFs… (this may take a few minutes)';
      const cfg = {
        letterHTML: document.getElementById('letterText').value,
        includeLOB: document.getElementById('includeLOB').checked,
        includeProducts: document.getElementById('includeProducts').checked,
        includeGeo: document.getElementById('includeGeo').checked
      };

      const zip = new JSZip();
      let done = 0;
      for (const partner of partners){
        const blob = await buildPdfForPartner(partner, cfg);
        const category = catMap[partner] || 'Others';
        const safeName = partner.replace(/[^\w\s-]/g,'').trim().replace(/\s+/g,'_');
        const safeCat  = category.replace(/[^\w\s-]/g,'').trim().replace(/\s+/g,'_');
        zip.file(`${safeCat}/${safeName}.pdf`, blob);
        done++;
        if (done % 10 === 0) statusEl.textContent = `Generated ${done}/${partners.length}…`;
        await new Promise(r => setTimeout(r, 10)); // yield to UI
      }

      const zipBlob = await zip.generateAsync({type:'blob'});
      const dlUrl = URL.createObjectURL(zipBlob);
      const a = document.createElement('a');
      a.href = dlUrl;
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      a.download = `Intermediary_PDFs_${ts}.zip`;
           a.click();
      statusEl.textContent = `Done — generated ${done} PDFs. ZIP downloaded.`;
    } catch (e) {
      console.error(e);
      document.getElementById('generateStatus').textContent = 'Error: '+e.message;
    }
  });
})();

</script>

</body>
</html>
